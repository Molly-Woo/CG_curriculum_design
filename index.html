<!DOCTYPE html>
<html lang="en">

<head>
    <title>水晶球世界</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="css/main.css">
</head>

<body>


    <div style="width: 350px;
                height: 400px;
                position: absolute;
                top: 50px;
                right: 0px;
                background-image: url(textures/paper.png);
                background-size:300px;
                background-repeat:no-repeat;
    ">
    <div class="incantation" style = "margin:65px 0 0 70px;height:40px;color: #fff; font-size: 20px;line-height: 40px;" onclick = "snow()">下雪了</div>
    <div class="incantation" id  = "btn2"style = "margin:25px 0 0 70px;height:40px;color: #fff; font-size: 20px;line-height: 40px;" onclick = "viewchange()">视角切换</div>
    <div class="incantation" style = "margin:25px 0 0 70px;height:40px;color: #fff; font-size: 20px;line-height: 40px;" onclick = "call()">召唤麋鹿</div>
    <div class="incantation" style = "margin:25px 0 0 70px;height:40px;color: #fff; font-size: 20px;line-height: 40px;" onclick = "turn_up()">点亮圣诞树</div>
    </div>
    <div id="snowBackground"></div>
    <script type="module" src="js/main.js"></script>
    <script type="text/javascript" src="js/back.js" ></script>
    <embed src="Jingle Bell.mp3" hidden="true" autostart="true" loop="true">
    <script>
         snow(){
         var width = 550; // 画布的宽度
         var height = 366; // 画布的高度

         // 渲染器
         var renderer = new THREE.WebGLRenderer({antialias:true});
         renderer.setSize(width, height);
         // 将canvas添加到指定元素
         var element = document.getElementById('snowBackground');
         element.appendChild(renderer.domElement);

         // 场景
         var scene = new THREE.Scene();
         // 正交投影摄像机
         var camera = new THREE.PerspectiveCamera(45, width/height, 2, 500);
         camera.position.set(0, 0, 40); // 摄像机位置
         // 照相机默认沿z轴负方向观察，通过设置lookAt的位置可以改变观察的方向
         camera.lookAt(new THREE.Vector3(0, 0, 0));
         scene.add(camera);

         var typeNum = 2; // 雪花种类
         var range = 50; // 雪花出现范围

        // 雪花纹理
        var texture = new THREE.TextureLoader().load('./snowflake.png');

        // 使用图片纹理材质
        var materials = [];
        for (var i = 0; i < typeNum; i++) {
        var material = new THREE.PointsMaterial({
        size: 2,
        map: texture, // 纹理
        transparent: true, // 透明
        opacity: 1, // 透明度
        depthTest: false, // 可以去掉texture的黑色背景
        blending: THREE.AdditiveBlending // 融合模式
    });
        material.map.offset = new THREE.Vector2(1/typeNum * i, 0);
        material.map.repeat = new THREE.Vector2(1/typeNum, 1);
        materials.push(material);
}

// 通过自定义几何体设置粒子位置
        var geoms = [];
        for (var k = 0; k < typeNum; k++) {
        var geom = new THREE.Geometry();
        for (var i = 0; i < 100; i++) {
        // 随机生成雪花的位置
        var v = new THREE.Vector3(
            Math.random() * range - range/2, 
            Math.random() * range - range/2,
            Math.random() * range - range/2
        );
        // 随机生成雪花分别沿x、y、z轴方向移动速度
        v.velocityY = 0.1 + Math.random() / 5;
        v.velocityX = (Math.random() - 0.5) / 3;
        v.velocityZ = (Math.random() - 0.5) / 3;
        // 添加顶点
        geom.vertices.push(v);
    }
        geoms.push(geom);
}

       // 点云
       var clouds = [];
       for (var i = 0; i < typeNum; i++) {
       var points = new THREE.Points(geoms[i], materials[i]);
       clouds.push(points)
       scene.add(points);
}

      (function animate () {
        clouds.forEach(function (points, i) {
        var vertices = points.geometry.vertices;
    
        vertices.forEach(function (v, idx) {
            // 计算位置
            v.y = v.y - (v.velocityY);
            v.x = v.x - (v.velocityX);
            v.z = v.z - (v.velocityZ);
            
            // 边界检查
            if (v.y <= -range/2) v.y = range / 2;
            if (v.x <= -range/2 || v.x >= range/2) v.x = v.x * -1;  
            if (v.z <= -range/2 || v.z >= range/2) v.velocityZ = v.velocityZ * -1;
        });

        //重要：渲染时需要更新位置（如果没有设为true,则无法显示动画）
        points.geometry.verticesNeedUpdate = true;
    });
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
})();
}

</script>
    
</body>
</html>